import numpy as np
import math

from .split import split1
from .util import add_value
from . import global_val as gv
import pdb


def __vert1(j, z, f, x1, x2, f1, f2):
    if j == 0:
        j1 = 1
    else:
        j1 = 0

    x = z[j1]
    if x1 == math.inf:
        x1 = z[j]
        f1 = f1 + f[j]
    elif x2 == math.inf and x1 != z[j]:
        x2 = z[j]
        f2 = f2 + f[j]

    return x, x1, x2, f1, f2


def __vert2(j, x, z, f, x1, x2, f1, f2):
    if j == 1:
        j1 = 2
    else:
        j1 = 1

    if x1 == math.inf:
        x1 = x[j]
        f1 = f1 + f[j]
        if x != z[j1]:
            x2 = z[j1]
            f2 = f2 + f[j1]
    elif x2 == math.inf and x1 != z[j]:
        x2 = z[j]
        f2 = f2 + f[j]
    elif x2 == math.inf:
        x2 = z[j1]
        f2 = f2 + f[j1]

    return x1, x2, f1, f2


def __vert3(j, x0, f0, L, x1, x2, f1, f2):
    if j == 0:
        k1 = 1
        k2 = 2
    elif j == L:
        k1 = L - 2
        k2 = L - 1
    else:
        k1 = j - 1
        k2 = j + 1

    x1 = x0[k1]
    x2 = x0[k2]
    f1 = f1 + f0[k1]
    f2 = f2 + f0[k2]

    return x1, x2, f1, f2


def __updtf(n, i, x1, x2, f1, f2, fold, f):
    for i1 in range(n):
        if i1 != i:
            if x1[i1] == math.inf:
                f1[i1] = f1[i1] + fold - f

            if x2[i1] == math.inf:
                f2[i1] = f2[i1] + fold - f

    # fold = f
    return f1, f2, f


def vertex(j, n, u, v, v1, x0, f0, ipar,
           isplit, ichild, z, f, l, L):
    """
    Computes the base vertex x and the opposite vertex y of the box # j
    of MCS and the 'neighboring vertices' x1 and x2 and their function
    values f1 and f2 needed for separable quadratic interpolation
    """

    # initialization
    # The coordinates of x, y, x1 and x2 are initially set
    # to Inf to indicate that these quantities haven't been
    # found yet in the course of pursuing the history of box j
    x = math.inf * np.ones((n, 1))
    y = math.inf * np.ones((n, 1))

    x1 = math.inf * np.ones((n, 1))
    x2 = math.inf * np.ones((n, 1))

    f1 = np.zeros((n, 1))
    f2 = np.zeros((n, 1))

    n0 = np.zeros((n, 1))

    if len(f.shape) == 2:
        fold = f[0, j]
    else:
        fold = f[j]
    m = j

    while m > 1:
        i = abs(isplit[ipar[m] - 1]) - 1
        n0[i] = n0[i] + 1
        if ichild[m] == 1:
            if x[i] == math.inf or x[i] == z[0, ipar[m]-1]:
                x[i], x1[i], x2[i], f1[i], f2[i] = __vert1(
                    1, z[:, ipar[m]-1], f[:, ipar[m]-1], x1[i, 0],
                    x2[i, 0], f1[i, 0], f2[i, 0])
            else:
                f1, f2, fold = __updtf(n, i, x1, x2, f1, f2,
                                       fold, f[0, ipar[m]-1])
                x1[i], x2[i], f1[i], f2[i] = __vert2(
                    0, x[i], z[:, ipar[m]-1], f[:, ipar[m]-1],
                    x1[i], x2[i], f1[i], f2[i])

        elif ichild[m] >= 2:
            f1, f2, fold = __updtf(n, i, x1, x2, f1, f2,
                                   fold, f[0, ipar[m]-1])
            if x[i] == math.inf or x[i] == z[1, ipar[m]-1]:
                x[i], x1[i], x2[i], f1[i], f2[i] = __vert1(
                    0, z[:, ipar[m]-1], f[:, ipar[m]-1], x1[i, 0],
                    x2[i, 0], f1[i, 0], f2[i, 0])
            else:
                x1[i], x2[i], f1[i], f2[i] = __vert2(
                    1, x[i], z[:, ipar[m]-1], f[:, ipar[m]-1],
                    x1[i], x2[i], f1[i], f2[i])

        if 1 <= ichild[m] and ichild[m] <= 2 and y[i] == math.inf:
            y[i] = split1(z[0, ipar[m]-1], z[1, ipar[m]-1],
                          f[0, ipar[m]-1], f[1, ipar[m]-1])

        # box m was generated by splitting according to the init. list
        # x0(i,j1) = ith coordinate of the base vertex of box m
        # the ith coordinate of the opposite vertex is the golden section
        # split of x0(i,j2) and x0(i,j2+1) for 1 <= j2 <= L(i) - 1, it is
        # u(i) for j1 = 1 and v(i) for j2 = L(i)
        # x0(i,j1+j3) = ith coordinate of the 'neighboring vertex'
        if ichild[m] < 0:
            if u[i] < x0[i, 0]:
                j1 = math.ceil(abs(ichild[m]) / 2)
                j2 = math.floor(abs(ichild[m]) / 2)
                if (abs(ichild[m]) / 2 < j1 and j1 > 1) | j1 == L[i, 0]:
                    j3 = -1
                else:
                    j3 = 1
            else:
                j1 = math.floor(abs(ichild[m]) / 2) + 1
                j2 = math.ceil(abs(ichild[m]) / 2)
                if abs(ichild[m])/2 + 1 > j1 and j1 < L[i, 0]:
                    j3 = 1
                else:
                    j3 = -1

            if isplit[ipar[m] - 1] < 0:
                k = i
            else:
                k = z[1, ipar[m] - 1]

            if j1 != l[i] or (x[i] != math.inf and x[i] != x0[i, l[i, 0]-1]):
                f1, f2, fold = __updtf(n, i, x1, x2, f1, f2,
                                       fold, f0[l[i, 0]-1, k])

            if x[i] == math.inf or x[i] == x0[i, j1-1]:
                x[i] = x0[i, j1-1]
                if x1[i] == math.inf:
                    x1[i], x2[i], f1[i], f2[i] = __vert3(
                        j1-1, x0[i, :], f0[:, k], L[i, 0]-1, x1[i, 0],
                        x2[i, 0], f1[i, 0], f2[i, 0])
                elif x2[i] == math.inf and x1[i] != x0[i, j1-1 + j3]:
                    x2[i] = x0[i, j1-1+j3]
                    f2[i] = f2[i] + f0[j1-1+j3, k]
                elif x2[i] == math.inf:
                    if j1 != 1 & j1 != L[i]:
                        x2[i] = x0[i, j1-1 - j3]
                        f2[i] = f2[i] + f0[j1-1-j3, k]
                    else:
                        x2[i] = x0[i, j1-1 + 2 * j3]
                        f2[i] = f2[i] + f0[j1-1 + 2 * j3, k]
            else:
                if x1[i] == math.inf:
                    x1[i] = x0[i, j1-1]
                    f1[i] = f1[i] + f0[j1-1, k]
                    if x[i] != x0[i, j1-1 + j3]:
                        x2[i] = x0[i, j1-1 + j3]
                        f2[i] = f2[i] + f0[j1-1+j3, k]
                elif x2[i] == math.inf:
                    if x1[i] != x0[i, j1-1]:
                        x2[i] = x0[i, j1-1]
                        f2[i] = f2[i] + f0[j1-1, k]
                    elif x[i] != x0[i, j1-1 + j3]:
                        x2[i] = x0[i, j1-1 + j3]
                        f2[i] = f2[i] + f0[j1-1 + j3, k]
                    else:
                        if j1 != 1 & j1 != L[i]:
                            x2[i] = x0[i, j1-1 - j3]
                            f2[i] = f2[i] + f0[j1-1 - j3, k]
                        else:
                            x2[i] = x0[i, j1-1 + 2 * j3]
                            f2[i] = f2[i] + f0[j1-1 + 2 * j3, k]

            if y[i] == math.inf:
                if j2 == 0:
                    y[i] = u[i]
                elif j2 == L[i]:
                    y[i] = v[i]
                else:
                    y[i] = split1(x0[i, j2-1], x0[i, j2-1 + 1],
                                  f0[j2-1, k], f0[j2-1 + 1, k])

        m = ipar[m] - 1

    for i in range(n):
        if x[i] == math.inf:
            x[i] = x0[i, l[i]-1]
            x1[i], x2[i], f1[i], f2[i] = __vert3(
                l[i, 0]-1, x0[i], f0[:, i], L[i, 0]-1, x1[i, 0],
                x2[i, 0], f1[i, 0], f2[i, 0])

        if y[i] == math.inf:
            y[i] = v1[i]

    return n0, x, y, x1, x2, f1, f2
